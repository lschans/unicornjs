/*
 This is the module that will do the bus initialize part

 */
/* Requiere modules*/
var listenClient = {},
    publishClient ={},
    busmsg = require('unicorn/bus-msg'),
    name = '',
    pid,
    Promise = require('es6-promise').Promise,
    redis = require('redis');

/**
 * Handler the initiation of the service
 * @param config
 * @param processID
 */
exports.init = function (config, processID) {

    name = config.process.name;
    pid = processID; // maybe this can be pass through config too... check later

    //var listenClient = Redis.createClient(config.redis.port, config.redis.server, {});
    // Listen to channel for requests
    var msg = busmsg.create(name,' ', pid);

    if (msg.serviceID.search('broker') != -1){
        publishClient.publish('broker-init', JSON.stringify(msg));
    }else{
        publishClient.publish('broker', JSON.stringify(msg));
    }
};

/**
 *
 * @param config
 * @param redisListenClient
 * @param redisPublishClient
 * @returns {*}
 */
exports.listenBroker = function (config, redisListenClient, redisPublishClient){
    // Make redis global in this module
    listenClient = redisListenClient;
    publishClient = redisPublishClient;

    return new Promise(function(resolve) {
        //var initChannel = Redis.createClient(config.redis.port, config.redis.server, {});
        // Catch redis errors
        listenClient.on("error", function (err) {
            console.log("Redis listen " + name + " error " + err);
        });
        // Catch redis message
        listenClient.on("message", function (channel, message) {
            /* Process incoming message and respond to response channel */
            /* listen to the new channel */
            var obj = JSON.parse(message);

            if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel != ' ') {
                console.log('broker responded something to me');
                //listenClient.unsubscribe();
                //listenClient.end();
                //this.serviceChannel(config, obj.channel, name);
                resolve(obj.respondChannel);
            }else if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel == ' ' && obj.serviceID.search('broker') != -1){
                // broker asking for channel
                publishClient.HINCRBY('broker', obj.serviceID+'_'+pid, 1); // add logic to active or not the state
                resolve(obj.serviceID+'_'+pid);
            }
        });

        listenClient.subscribe('broker-init');
    });
};

/**
 * Listen to the channel assigned by the broker and execute the method required
 * @param config
 * @param channel
 * @param name
 */
exports.serviceChannel = function (config, channel, name){
    var clientRedis = Redis.createClient(config.redis.port, config.redis.server, {});
    var resposeRedis = Redis.createClient(config.redis.port, config.redis.server, {});

    clientRedis.on('error', function (err) {
        console.log("Redis listen "+name+" error " + err);
    });

    clientRedis.on('message', function (channel, message) {
        //here comes the logic of module that is being execute
        console.log('Im the service and I have job to do!');
        var obj = JSON.parse(message);
        var result = 'Doing smt with this: '+(obj.data[0].value);
        var response =  {"result" : result, "ack": 0};
        //publish response in the channel of the service
        resposeRedis.publish(obj.channel, JSON.stringify(response));
    });

    clientRedis.subscribe(channel);
};

exports.getChannel = function (config, Channel) {
    //start listening in the channel assigned
    var internalListenChannel = redis.createClient(config.redis.port, config.redis.server, {}); // Refactor this names

    internalListenChannel.on('error', function (err) {
        console.log("Redis listen error " + err);
    });

    internalListenChannel.on('message', function (channel, message) {
        var msg = JSON.parse(message);
        if (!busmsg.verify(msg)) {
            console.log('Wrong Message Format!');
        } else {
            console.log('I am '+config.process.name+' So, this broker has a message to transmit');
            //Passing the msg to the worker
            if (pids.length > 0) { // Check if we have workers to balance to
                if (rrCounter > (pids.length - 1)) rrCounter = 0;
                // Forward the message to the next available worker
                workers[pids[rrCounter++]].send({pid: process.pid, type: 'MSG', msg: message});
            } else { // No workers up
                masterObj.errorLogic('No workers available');
            }
        }
    });

    // check if the message belongs to a broker
    if (Channel.search('broker') != -1){ // Checking if the service is a broker!
        var brokerClient =  redis.createClient(config.redis.port, config.redis.server, {});

        brokerClient.on('error', function (err) {
            console.log("Redis listen error " + err);
        });

        brokerClient.on('message', function (channel, message) {
            // do something

            console.log(message);

            var msg = JSON.parse(message);

            if (!busmsg.verify(msg)) {
                console.log('Wrong Message Format!');
            } else {
                // Assign a broker
                areThereBrokers().then(function (boolean) {
                    if (boolean){
                        checkBrokerFlag().then(function (brokerAvailable) {
                            publishClient.publish(brokerAvailable, message);
                        });
                    }else{
                        publishClient.publish('broker', message);
                    }
                });
            }
        });
        //Broker will listen in two channel
        brokerClient.subscribe('broker');
        internalListenChannel.subscribe(Channel);
    }else { // if is not a broker just publish the msg
        internalListenChannel.subscribe(Channel); // when a simple service (not broker) has a channel
    }
};

function checkBrokerFlag (){
    return new Promise(function (resolve, reject) {
        publishClient.HGETALL('broker', function (err, hash) {
            if (err) reject(err);
            else{
                if (typeof (hash) != 'undefined'){ // There are brokers working
                    var aux;
                    for (var broker in hash){
                        if (hash[broker] == '1') {
                            activateBrokerFlag().then(function (brokerActive) {
                                publishClient.HSET('broker', broker, 0);
                                resolve(broker); // return the first it gets
                            })
                        }
                        aux = broker;
                    }
                    // decide if send the last one
                }
            }
        })
    })
}

function activateBrokerFlag (){
    return new Promise(function (resolve, reject) {
        publishClient.HGETALL('broker', function (err, hash) {
            if (err) reject(err);
            else{
                var aux;
                if (typeof (hash) != 'undefined'){ // There are brokers working
                    for (var broker in hash){
                        if (hash[broker] == '0') {
                            publishClient.HSET('broker', broker, 1);
                            resolve(broker); // return the first it gets
                        }
                        aux = broker;
                    }
                    publishClient.HSET('broker', aux, 1)
                    resolve(aux);
                }
            }
        })
    })
}

function areThereBrokers (){
    return new Promise(function (resolve, reject) {
        publishClient.HGETALL('broker', function (err, hash) {
            if (err) reject(err);
            else{
                if (JSON.stringify(hash) == "{}") {
                    resolve(false)
                } else {
                    resolve(true)
                }
            }
        });
    });
}