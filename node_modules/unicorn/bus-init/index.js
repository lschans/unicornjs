/*
 This is the module that will do the bus initialize part

 */
/* Requiere modules*/
var listenClient = {},
    publishClient ={},
    busmsg = require('unicorn/bus-msg'),
    name = '',
    pid,
    Promise = require('es6-promise').Promise,
    redis = require('redis');

/**
 * Handler the initiation of the service
 * @param config
 * @param processID
 */
exports.init = function (config, processID) {

    name = config.process.name;
    pid = processID; // maybe this can be pass through config too... check later

    // Listen to channel for requests
    var msg = busmsg.create(name,' ', pid);

    publishClient.publish('broker-init', JSON.stringify(msg));
};

/**
 *
 * @param config
 * @param redisListenClient
 * @param redisPublishClient
 * @returns {*}
 */
exports.listenBroker = function (config, redisListenClient, redisPublishClient){
    // Make redis global in this module
    listenClient = redisListenClient;
    publishClient = redisPublishClient;

    return new Promise(function(resolve) {
        // Catch redis errors
        var name = config.process.name,
            pid = process.pid;

        listenClient.on("error", function (err) {
            console.log("Redis listen " + name + " error " + err);
        });
        // Catch redis message
        listenClient.on("message", function (channel, message) {
            /* Process incoming message and respond to response channel */
            /* listen to the new channel */

            var obj = JSON.parse(message);

            if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel != ' ') {

                if (obj.ack == 1){
                    console.log('broker responded something to me');
                    console.log(message);
                    resolve(obj.respondChannel);
                }
                else{
                    console.log('0 - AM A MSG');
                    resolve(obj.respondChannel);
                }
                //listenClient.unsubscribe();
                //listenClient.end();
                //this.serviceChannel(config, obj.channel, name);
            }else if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel == ' ' && obj.serviceID.search('broker') == -1){
                //verify if anyone is listening on broker
                publishClient.publish('broker', message, function (err, number) {
                    if (number == 0){ // there is nobdy yet listening in broker channel
                        publishClient.publish('broker-init', message);
                    }
                });
            }else if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel == ' ' && obj.serviceID.search('broker') != -1){
                // broker asking for channel
                publishClient.HINCRBY('broker', obj.serviceID+'_'+pid, 1); // add logic to active or not the state
                resolve(obj.serviceID+'_'+pid);
            }
        });

        listenClient.subscribe('broker-init');
    });
};

exports.getChannel = function (config, Channel) {
    return new Promise(function (resolve, reject) {

        //start listening in the channel assigned
        var internalListenChannel = redis.createClient(config.redis.port, config.redis.server, {}); // Refactor this names

        internalListenChannel.on('error', function (err) {
            console.log("Redis listen error " + err);
        });

        internalListenChannel.on('message', function (channel, message) {
            var msg = JSON.parse(message);
            if (!busmsg.verify(msg)) {
                console.log('Wrong Message Format!');
            } else {
                console.log('I am '+config.process.name);
                //Passing the msg to the worker
                resolve(message);
            }
        });

        // check if the message belongs to a broker
        if (Channel.search('broker') != -1){ // Checking if the service is a broker!

            console.log('Broker Message');
            var brokerClient =  redis.createClient(config.redis.port, config.redis.server, {});

            brokerClient.on('error', function (err) {
                console.log("Redis listen error " + err);
            });

            brokerClient.on('message', function (channel, message) {
                // do something
                var msg = JSON.parse(message);

                if (!busmsg.verify(msg)) {
                    console.log('Wrong Message Format!');
                } else {
                    // Assign a broker
                    areThereBrokers().then(function (boolean) {
                        if (boolean){
                            checkBrokerFlag().then(function (brokerAvailable) {
                                console.log('aqui '+msg.serviceRequired+' '+brokerAvailable);
                                if (typeof (brokerAvailable) == 'undefined')
                                    publishClient.publish('broker', message);
                                else
                                    publishClient.publish(brokerAvailable, message);
                            });
                        }else{
                            publishClient.publish('broker', message);
                        }
                    });
                }
            });
            //Broker will listen in two channel
            brokerClient.subscribe('broker');
            internalListenChannel.subscribe(Channel);
        }else { // if is not a broker just publish the msg

            console.log('This is not happening');
            internalListenChannel.subscribe(Channel); // when a simple service (not broker) has a channel
        }
    });

};

/**
 * Listen to the channel assigned by the broker and execute the method required
 * @param config
 * @param channel
 * @param name
 */
exports.serviceChannel = function (config, channel, name){

    new Promise(function(resolve, reject){
        var clientRedis = Redis.createClient(config.redis.port, config.redis.server, {});
        var resposeRedis = Redis.createClient(config.redis.port, config.redis.server, {});

        clientRedis.on('error', function (err) {
            console.log("Redis listen "+name+" error " + err);
        });

        clientRedis.on('message', function (channel, message) {
            //here comes the logic of module that is being execute
            console.log('Im the service and I have job to do!');
            //var obj = JSON.parse(message);
            //var result = 'Doing smt with this: '+(obj.data[0].value);
            //var response =  {"result" : result, "ack": 0};
            //publish response in the channel of the service
            resolve(response);
        });

        clientRedis.subscribe(channel);
    });

};



function checkBrokerFlag (){
    return new Promise(function (resolve, reject) {
        publishClient.HGETALL('broker', function (err, hash) {
            if (err) reject(err);
            else{
                if (typeof (hash) != 'undefined'){ // There are brokers working
                    var aux;
                    for (var broker in hash){
                        if (hash[broker] == '1') {
                            activateBrokerFlag().then(function (brokerActive) {
                                publishClient.HSET('broker', broker, 0);
                                resolve(broker); // return the first it gets
                            })
                        }
                        aux = broker;
                    }
                    // decide if send the last one
                }
            }
        })
    })
}

function activateBrokerFlag (){
    return new Promise(function (resolve, reject) {
        publishClient.HGETALL('broker', function (err, hash) {
            if (err) reject(err);
            else{
                var aux;
                if (typeof (hash) != 'undefined'){ // There are brokers working
                    for (var broker in hash){
                        if (hash[broker] == '0') {
                            publishClient.HSET('broker', broker, 1);
                            resolve(broker); // return the first it gets
                        }
                        aux = broker;
                    }
                    publishClient.HSET('broker', aux, 1)
                    resolve(aux);
                }
            }
        })
    })
}

function areThereBrokers (){
    return new Promise(function (resolve, reject) {
        publishClient.HGETALL('broker', function (err, hash) {
            if (err) reject(err);
            else{
                if (JSON.stringify(hash) == "{}") {
                    resolve(false)
                } else {
                    resolve(true)
                }
            }
        });
    });
}