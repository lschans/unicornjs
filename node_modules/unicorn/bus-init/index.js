/*
 This is the module that will do the bus initialize part

 */
/* Requiere modules*/
var listenClient = {},
    publishClient ={},
    busmsg = require('unicorn/bus-msg'),
    name = '',
    pid,
    Promise = require('es6-promise').Promise;

/**
 * Handler the initiation of the service
 * @param config
 * @param proccesID
 */
exports.init = function (config, processID) {

    name = config.process.name;
    pid = processID; // maybe this can be pass through config too... check later

    //var listenClient = Redis.createClient(config.redis.port, config.redis.server, {});
    // Listen to channel for requests
    var msg = busmsg.create(name,' ', pid);

    if (msg.serviceID.search('broker') != -1){
        publishClient.publish('broker-init', JSON.stringify(msg));
    }else{
        publishClient.publish('broker', JSON.stringify(msg));
    }


};

/**
 * Listen to the broker channel until receive the channel where this service should be listening for jobs
 * @param config
 * @param name
 */
exports.listenBroker = function (config, redisListenClient, redisPublishClient){
    // Make redis global in this module
    listenClient = redisListenClient;
    publishClient = redisPublishClient;

    return new Promise(function(resolve) {
        //var initChannel = Redis.createClient(config.redis.port, config.redis.server, {});
        // Catch redis errors
        listenClient.on("error", function (err) {
            console.log("Redis listen " + name + " error " + err);
        });
        // Catch redis message
        listenClient.on("message", function (channel, message) {
            /* Process incoming message and respond to response channel */
            /* listen to the new channel */
            var obj = JSON.parse(message);

            if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel != ' ') {
                console.log('broker responded something to me');
                //listenClient.unsubscribe();
                //listenClient.end();
                //this.serviceChannel(config, obj.channel, name);
                resolve(obj.respondChannel);
            }else if (obj.serviceID == name && obj.msgpid == pid  && obj.respondChannel == ' ' && obj.serviceID.search('broker') != -1){
                // broker asking for channel
                publishClient.HINCRBY('broker', obj.serviceID+'_'+pid, 1); // add logic to active or not the state
                resolve(obj.serviceID+'_'+pid);
            }
        });

        listenClient.subscribe('broker-init');
    });
};

/**
 * Listen to the channel assigned by the broker and execute the method required
 * @param config
 * @param channel
 * @param name
 */
exports.serviceChannel = function (config, channel, name){
    var clientRedis = Redis.createClient(config.redis.port, config.redis.server, {});
    var resposeRedis = Redis.createClient(config.redis.port, config.redis.server, {});

    clientRedis.on('error', function (err) {
        console.log("Redis listen "+name+" error " + err);
    });

    clientRedis.on('message', function (channel, message) {
        //here comes the logic of module that is being execute
        console.log('Im the service and I have job to do!');
        var obj = JSON.parse(message);
        var result = 'Doing smt with this: '+(obj.data[0].value);
        var response =  {"result" : result, "ack": 0};
        //publish response in the channel of the service
        resposeRedis.publish(obj.channel, JSON.stringify(response));
    });

    clientRedis.subscribe(channel);
};