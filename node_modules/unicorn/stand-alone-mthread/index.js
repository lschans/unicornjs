/*************************************************
 Template for a 'multi-threaded micro-service' that listens on a Redis channel.
 By: Lars van der Schans ( 2015 )
 *************************************************/

//  TODO: When asks for an gracefull exit, look if there are more than 1 workers active, if not, ask to reschedule restart.
//  TODO: Other way of balancing; 1 Random:Pick a random thread and send the message; 2 Job based, send JobCount to master on change of job count, the process with the least jobs will get it.

var Path = require('path');

var businit = require('unicorn/bus-init'); // Every service has to be initialize and bus-init make that possible
var busmsg = require('unicorn/bus-msg'); // Every service has to be initialize and bus-init make that possible

module.exports = function (config, redis) {
   var cluster = require('cluster'),
       masterObj = require(Path.join(config.rootdir, 'unicorn_services', config.process.name, config.process.masterCode))(config, redis),
       workerObj = require(Path.join(config.rootdir, 'unicorn_services', config.process.name, config.process.workerCode))(config, redis);

    // Schedule an automated exit of the thread to keep threads fresh
    function scheduleExit() {
        // Randomly kill a process graceful for stability and micro service logic
        var dieIn = Math.round(Math.random() * (config.process.maxThreadLifetime - config.process.minThreadLifetime) + config.process.minThreadLifetime);
        var dieTimer = setTimeout(function() {
            // Tell the master that you want to exit. EXIT type is enough
            process.send({pid:process.pid, type:'EXIT', msg:''});
        }, dieIn);
        // Send some status info to stdout
        console.log(process.pid + ' is scheduled to die in ' + Math.round(dieIn / 1000) + ' seconds.');
        return dieTimer;
    }

   /*************************************************
    A min and max time for a service to die seems odd, actually in microService land this is good practice.
    Since we don't care a single bit about a process it's good to kill them every once in a while; this also prevents weird errors like memory leaks.
    In a production environment this should be somewhere in between 1 and 15 minutes
    * For production use, the interval on top of the master section needs to be removed, this interval only supplies a test pub to the listen channel
    * For testing purposes, this demo service kills workers in a dirty and in a gracefull way.
    * The dirty way should be removed in production use, if you want to keep a simulation of a 'crash' use a timer and not a randBool
    =*************************************************=
    Message template for internal messaging: {pid:process.pid, type:'EXIT', msg:''}
    Message types:
       EXIT=exit signal,
       MSG=normal message,
       ERROR=error message
    *************************************************/

   if (cluster.isMaster) { // Master state, this code will be executed by the master process
       var listenClient = redis.createClient(config.redis.port, config.redis.server, {}),
           publishClient = redis.createClient(config.redis.port, config.redis.server, {}),
           workers = {}, pids = [], rrCounter = 0;

       /******************************************************************************/
       // WHEN MASTER START I SHOULD SAVE THE MASTER PROCESS IN THE CONFIG OBJECT!!!!
       /*****************************************************************************/
       // Every Service Should be initialize

       businit.listenBroker(config, listenClient, publishClient).then(function (Channel) {
           businit.getChannel(config, Channel).then(function (message) {
               if (pids.length > 0) { // Check if we have workers to balance to
                   if (rrCounter > (pids.length - 1)) rrCounter = 0;
                   // Forward the message to the next available worker
                   workers[pids[rrCounter++]].send({pid: process.pid, type: 'MSG', msg: message});
                   console.log('Sending message to: ' + pids[rrCounter++], message);
               } else { // No workers up
                   // Try to spawn a new worker if the number of workers didn't exceed the max threads value
                   masterObj.errorLogic('No workers available try to spawn one for you; workers:' + Object.keys(workers).length);
                   if(Object.keys(workers).length < config.process.maxthreads) {
                       masterObj.errorLogic('I can spawn, so I will; workers:' + Object.keys(workers).length);
                       spawnWorker(function(){
                           if (rrCounter > (pids.length - 1)) rrCounter = 0;
                           // Forward the message to the next available worker
                           workers[pids[rrCounter++]].send({pid:process.pid, type:'MSG', msg:message});
                       });
                   } else {
                       masterObj.errorLogic('Cant spawn and no workers available; workers:' + Object.keys(workers).length);
                   }
               }
           });
       });

       // Ask broker for channel
       businit.init(config, process.pid); // this send the first message

       //Execute injected start code
       if(typeof(masterObj.startLogic) == 'function') {
           masterObj.startLogic(config, redis);
       }

       // Handle crashes from workers and dirty exits
       cluster.on('exit', function(worker, code, signal) {
           if (typeof(workers[worker.process.pid]) != 'undefined') { // Worker crashed and didn't shut down gracefully
               // Put a message on stdout
               masterObj.errorLogic('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal);

               if(Object.keys(workers).length <= config.process.threads) { // Remove worker and spawn a new one
                   masterObj.errorLogic('Less workers than minimum spawning a new one; workers:' + Object.keys(workers).length);
                   removeWorker(worker.process.pid, spawnWorker);
               } else { // Just remove the worker
                   masterObj.errorLogic('More workers than minimum just delete this worker; workers:' + Object.keys(workers).length);
                   removeWorker(worker.process.pid, function(){});
               }
           } else { // Worker had a gracefull shutdown, we will start a new worker instead if we need more workers
               if(Object.keys(workers).length < config.process.threads) {
                   masterObj.errorLogic('Gracefull shutdown spawning new worker; workers:' + Object.keys(workers).length);
                   spawnWorker();
               } else {
                   masterObj.errorLogic('Gracefull shutdown dont need a new worker; workers:' + Object.keys(workers).length);
               }
           }
       });

       function removeWorker(workerPID, callback) {
           //Delete worker entry from worker object
           delete workers[workerPID];

           //Remove pid from pid array
           var position = pids.indexOf(workerPID);
           if (~position) pids.splice(position, 1);
           //Reset array index
           pids = pids.filter(function(){return true;});

           // Call the callback if its defined
           if(typeof(callback) == 'function') callback(workerPID);
       }

       function spawnWorker(callback){
           var tmpWorker = cluster.fork();
           workers[tmpWorker.process.pid] = tmpWorker;

           // Make sure we can receive messages from our worker
           workers[tmpWorker.process.pid].on('message', function(message) {
               masterProcessMessage(message);
           });

           pids.push(tmpWorker.process.pid);

           if(typeof(callback) == 'function') callback();
       }

       // Fork the worker processes
       console.log('Master cluster setting up ' + config.process.threads + ' workers...');
       for (var i = 0; i < config.process.threads; i++) {
           spawnWorker();
       }

   } else { // Worker state, this code will be executed by workers
       //Execute injected start code
       if(typeof(workerObj.startLogic) == 'function') workerObj.startLogic(config, redis);

       var jobCount = 0; // Worker is idle on start, 0 jobs on the list

       process.on('message', function(message) {
           try {
               var o = JSON.parse(message);

               // Handle non-exception-throwing cases:
               // Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,
               // but... JSON.parse(null) returns 'null', and typeof null === "object",
               // so we must check for that, too.
               if (o && typeof o === "object" && o !== null) {
                   message = o;
               }
           }
           catch (e) { }
           workerProcessMessage(message);
       });

       scheduleExit();

        // Send some status info to stdout
       console.log(process.pid + ' is up!');
   }

   function masterProcessMessage(message) {
       /*************************************************
        Do a lot of stuff with the incoming message here and respond an answer to redis
        This is the place where the success, code done, message processed, etc happens
        *************************************************/

       // Test the message for a type, if there is a type switch it
       if(typeof(message.type) !== 'undefined'){
           // Process message
           switch(message.type){
               case 'MSG':
                   masterObj.workLogic(message.msg);
                   break;

               case 'EXIT': // Since we are the master, this means that this is an exit request
                   // What we will do is respond that it's okay to exit and unregister the worker

                   // If there is one thread or less, dont allow the exit, and ask for a reschedule
                   if(Object.keys(workers).length <= 1) {
                       workers[message.pid].send({pid:process.pid, type:'EXIT', msg:'{"action":"reschedule"}'});
                   } else {
                       workers[message.pid].send({pid:process.pid, type:'EXIT', msg:'{"action":"exit"}'});
                       removeWorker(message.pid);
                   }
                   break;

               case 'ERROR':
                   masterObj.errorLogic(message.msg);
                   break;

               default:
                   masterObj.errorLogic('unknown message format');
                   break;
           }
       } else {
           masterObj.errorLogic('unknown message format');
       }
   }

   function workerProcessMessage(message) {
       /*************************************************
        Do a lot of stuff with the incoming message here and respond an answer to the master
        This is the place where all the worker logic takes place
        Make sure to handle possible message types
        *************************************************/

       console.log('Got a message from:' + message.pid + ' With type: ' + message.type);

       // Test the message for a type, if there is a type switch it
       if(typeof(message.type) !== 'undefined'){
           // Process message
           switch(message.type){
               case 'MSG':
                   // Add worker logic here
                   jobCount++; // Add a job to the list
                   workerObj.workLogic(message.msg, function (err, result) {
                       if (err) {
                           process.send({pid:process.pid, type:'ERROR', msg:err});
                       } else {
                           console.log('Callback from worker:', result);
                           process.send({pid:process.pid, type:'MSG', msg:result});
                       }
                       jobCount--; // Substract job when we are done
                   });
                   break;

               case 'EXIT': // Mind if you receive an exit, than you must exit
                   var action = JSON.parse(message.msg).action;  // TODO: Add test to see if there is a valid message.. use Joy?
                   if(action == 'exit') {
                       // We received an exit signel, we will wait untill we are idle and then exit
                       console.log('(' + process.pid + ')' + 'Kill signal received waiting for active jobs:' + jobCount);
                       setInterval(function() { // Keep looping untill we are idle
                           if(jobCount == 0) {
                               console.log('PID: ' + process.pid + ', says bye bye..');
                               process.exit();
                           }
                       }, 500);
                   } else if(action == 'reschedule') {
                       // Reschedule an automated exit
                       scheduleExit();
                   } else {
                       // action is undefined or unkonwn.. let's do nothing
                       console.log('Unknown exit action');
                   }
                   break;

               case 'ERROR':
                   console.log('There must be something wrong, I received an error..', message);
                   break;

               default:
                   process.send({pid:process.pid, type:'ERROR', msg:'unknown message format'});
                   break;
           }
       } else {
           process.send({pid:process.pid, type:'ERROR', msg:'unknown message format'});
       }
   }
};