/*************************************************
 Template for a 'multi-threaded micro-service' that listens on a Redis channel.
 By: Lars van der Schans ( 2015 )
 *************************************************/

var Path = require('path');

var businit = require('unicorn/bus-init');

module.exports = function (config, redis) {
   var cluster = require('cluster'),
       masterObj = require(Path.join(config.rootdir, 'unicorn_services', config.process.name, config.process.masterCode))(config, redis),
       workerObj = require(Path.join(config.rootdir, 'unicorn_services', config.process.name, config.process.workerCode))(config, redis);

   /*************************************************
    A min and max time for a service to die seems odd, actually in microService land this is good practice.
    Since we don't care a single bit about a process it's good to kill them every once in a while; this also prevents weird errors like memory leaks.
    In a production environment this should be somewhere in between 1 and 15 minutes
    * For production use, the interval on top of the master section needs to be removed, this interval only supplies a test pub to the listen channel
    * For testing purposes, this demo service kills workers in a dirty and in a gracefull way.
    * The dirty way should be removed in production use, if you want to keep a simulation of a 'crash' use a timer and not a randBool
    =*************************************************=
    Message template for internal messaging: {pid:process.pid, type:'EXIT', msg:''}
    Message types:
       EXIT=exit signal,
       MSG=normal message,
       ERROR=error message
    *************************************************/

   if (cluster.isMaster) { // Master state, this code will be executed by the master process
       var listenClient = redis.createClient(config.redis.port, config.redis.server, {}),
           publishClient = redis.createClient(config.redis.port, config.redis.server, {}),
           workers = {}, pids = [], rrCounter = 0;

       // Catch errors to make sure the master process keeps running
       listenClient.on("error", function (err) {
           masterObj.errorLogic("Redis listen error: " + err);
       });
/*
       process.on('uncaughtException', function(err) {
           masterObj.errorLogic('Process exception: ' + err);
       });
*/
       // Process redis message
       listenClient.on("message", function (channel, message) {
           if(pids.length > 0) { // Check if we have workers to balance to
               if (rrCounter > (pids.length - 1)) rrCounter = 0;
               // Forward the message to the next available worker
               workers[pids[rrCounter++]].send({pid:process.pid, type:'MSG', msg:message});
           } else { // No workers up
               masterObj.errorLogic('No workers available');
           }
       });

       // Listen to channel for requests
       // This should change because we need te request the channel from the broker
       // Should be broker init at first
       businit.listenBroker(config, listenClient, publishClient).then(function (channel) {
           //start listening in the channel assigned
           var internalListenChannel = redis.createClient(config.redis.port, config.redis.server, {});
           var internalPublicnChannel = redis.createClient(config.redis.port, config.redis.server, {});

           internalListenChannel.on('error', function (err) {
               console.log("Redis listen [math] error " + err);
           });

           internalListenChannel.on('message', function (channel, message) {
               // do something
               var msg = JSON.parse(message);
               console.log('Im the service '+msg.serviceID+' and I have job to do!');
               if (!busmsg.verify(msg))
                   console.log('Wrong Message Format!');
               else {
                   //Particular logic of the service... that's why this shoud be a internal module in each service
                   internalPublicnChannel.publish(msg.respondChannel, JSON.stringify(msg));
               }
           });

           listenClient.subscribe(channel);
       });

       // Should be broker init at first
       businit.init(config, process.pid);

       // Ask broker for channel

       // Start listening on the channel

       // Should be broker init at first
       listenClient.subscribe('broker-init');

       //listenClient.subscribe(config.initChannel);

       //Execute injected start code
       if(typeof(masterObj.startLogic) == 'function') {
           masterObj.startLogic(config, redis);
       }

       // Handle crashes from workers and dirty exits
       cluster.on('exit', function(worker, code, signal) {
           if (typeof(workers[worker.process.pid]) != 'undefined') { // Worker crashed and didn't shut down gracefully
               removeWorker(worker.process.pid, spawnWorker);

               // Put a message on stdout
               console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal);
           } else { // Worker had a gracefull shutdown, we will start a new worker instead
               spawnWorker();
           }
       });

       function removeWorker(workerPID, callback) {
           //Delete worker entry from worker object
           delete workers[workerPID];

           //Remove pid from pid array
           var position = pids.indexOf(workerPID);
           if (~position) pids.splice(position, 1);
           //Reset array index
           pids = pids.filter(function(){return true;});

           // Call the callback if its defined
           if(typeof(callback) == 'function') callback(workerPID);
       }

       function spawnWorker(){
           var tmpWorker = cluster.fork();
           workers[tmpWorker.process.pid] = tmpWorker;

           // Make sure we can receive messages from our worker
           workers[tmpWorker.process.pid].on('message', function(message) {
               masterProcessMessage(message);
           });

           pids.push(tmpWorker.process.pid);
       }

       // Fork the worker processes
       console.log('Master cluster setting up ' + config.process.threads + ' workers...');
       for (var i = 0; i < config.process.threads; i++) {
           spawnWorker();
       }

   } else { // Worker state, this code will be executed by workers
       process.on('message', function(message) {
           try {
               var o = JSON.parse(message);

               // Handle non-exception-throwing cases:
               // Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,
               // but... JSON.parse(null) returns 'null', and typeof null === "object",
               // so we must check for that, too.
               if (o && typeof o === "object" && o !== null) {
                   message = o;
               }
           }
           catch (e) { }
           workerProcessMessage(message);
       });

       // Randomly kill a process graceful for stability and micro service logic
       var dieIn = Math.round(Math.random() * (config.process.maxThreadLifetime - config.process.minThreadLifetime) + config.process.minThreadLifetime);
       setTimeout(function() {
           // Tell the master that you want to exit. EXIT type is enough
           process.send({pid:process.pid, type:'EXIT', msg:''});
       }, dieIn);

       //Execute injected start code
       if(typeof(workerObj.startLogic) == 'function') workerObj.startLogic(config, redis);

       // Send some status info to stdout
       console.log(process.pid + ' is up and will die in ' + Math.round(dieIn / 1000) + ' seconds.');
   }

   function masterProcessMessage(message) {
       /*************************************************
        Do a lot of stuff with the incoming message here and respond an answer to redis
        This is the place where the success, code done, message processed, etc happens
        *************************************************/

       // Test the message for a type, if there is a type switch it
       if(typeof(message.type) !== 'undefined'){
           // Process message
           switch(message.type){
               case 'MSG':
                   masterObj.workLogic(message.msg);
                   break;

               case 'EXIT': // Since we are the master, this means that this is an exit request
                   // What we will do is respond that it's okay to exit and unregister the worker
                   workers[message.pid].send({pid:process.pid, type:'EXIT', msg:''});
                   removeWorker(message.pid);
                   break;

               case 'ERROR':
                   masterObj.errorLogic(message.msg);
                   break;

               default:
                   masterObj.errorLogic('unknown message format');
                   break;
           }
       } else {
           masterObj.errorLogic('unknown message format');
       }
   }

   function workerProcessMessage(message) {
       /*************************************************
        Do a lot of stuff with the incoming message here and respond an answer to the master
        This is the place where all the worker logic takes place
        Make sure to handle possible message types
        *************************************************/

       // Test the message for a type, if there is a type switch it
       if(typeof(message.type) !== 'undefined'){
           // Process message
           switch(message.type){
               case 'MSG':
                   // Add worker logic here
                   workerObj.workLogic(message.msg, function (err, result) {
                       if (err) {
                           process.send({pid:process.pid, type:'ERROR', msg:err});
                       } else {
                           process.send({pid:process.pid, type:'MSG', msg:result});
                       }
                   });
                   break;

               case 'EXIT': // Mind if you receive an exit, than you must exit
                   console.log('PID: ' + process.pid + ', says bye bye..');
                   process.exit();
                   break;

               case 'ERROR':
                   console.log('There must be something wrong, I received an error..', message);
                   break;

               default:
                   process.send({pid:process.pid, type:'ERROR', msg:'unknown message format'});
                   break;
           }
       } else {
           process.send({pid:process.pid, type:'ERROR', msg:'unknown message format'});
       }
   }
};