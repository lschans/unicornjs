

var service = {
    getAnswer: function(service, serviceRequired, functionName, value, pid, config) {
        var redis = require('redis'),
            busmsg = require('unicorn//bus-msg'),
            Promise = require('es6-promise').Promise;


        return new Promise(function(resolve) {
            // This is where we should post crap to the bus and do some async wait thingys
            // Replace this crap and send it over the message bus

            var respondChannel = service + 'Channel' + '_' + pid;

            console.log('bustalk in action -> send message now respond to: ' + respondChannel);

            // It is hanging here and then it will work
            console.log(config.process.name, respondChannel, pid);
            var msg = busmsg.create(config.process.name, respondChannel, pid);

            console.log('bustalk step 2');
            msg.serviceRequired = serviceRequired;
            msg.function = functionName;
            msg.data.push = {"value": value};
            //create a client

            var publishClient = redis.createClient(config.redis.port, config.redis.server, {});
            var listenClient = redis.createClient(config.redis.port, config.redis.server, {});

            console.log('bustalk publishing to broker now');
            publishClient.publish('broker', JSON.stringify(msg), function (err, number) {

                console.log(number);
                if (number == 0 ){
                    publishClient.publish('broker', JSON.stringify(msg))
                }

            });
            /* Listener waiting for the answer */
            listenClient.on("message", function (channel, message) {
                /* Process incoming message and respond to response channel */
                /* listen to the new channel */
                var obj = JSON.parse(message);

                console.log(obj);
                if (obj.ack == 0){
                    listenClient.unsubscribe();
                    listenClient.end();
                    resolve(obj.result);
                }
            });
            listenClient.subscribe(respondChannel);
        });
    },
    sendAnswer: function(service, respondServiceChannel, functionName, value, pid, config) {
        var redis = require('redis'),
            busmsg = require('unicorn//bus-msg'),
            Promise = require('es6-promise').Promise;

        return new Promise(function(resolve) {
            // This is where we should post crap to the bus and do some async wait thingys
            // Replace this crap and send it over the message bus

            var respondChannel = service + 'Channel' + '_' + pid;

            console.log('bustalk in action -> send message now respond to: ' + respondChannel);

            // It is hanging here and then it will work
            console.log(config.process.name, respondChannel, pid);
            var msg = busmsg.create(config.process.name, respondChannel, pid);

            console.log('bustalk step 2');
            msg.serviceRequired = ' ';
            msg.function = functionName;
            msg.data.push = {"value": value};
            //create a client

            var publishClient = redis.createClient(config.redis.port, config.redis.server, {});
            var listenClient = redis.createClient(config.redis.port, config.redis.server, {});

            console.log('bustalk publishing to broker now');
            publishClient.publish(respondServiceChannel, JSON.stringify(msg), function (err, number) {

                if (number == 0 ){
                    resolve(number)
                }


                //console.log(number);
                //if (number == 0 ){
                //    publishClient.publish('broker', JSON.stringify(msg))
                //}

            });
            /* Listener waiting for the answer */
            listenClient.on("message", function (channel, message) {
                /* Process incoming message and respond to response channel */
                /* listen to the new channel */
                var obj = JSON.parse(message);

                console.log(obj);
                if (obj.ack == 0){
                    listenClient.unsubscribe();
                    listenClient.end();
                    resolve(obj.result);
                }
            });
            listenClient.subscribe(respondChannel);
        });
    }
};

module.exports = service;